package Lessons.Collection;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class BigONotation {
    public static void main(String[] args) {
        /** Big O Notation
         * Служит для описания сложности алгоритмов. За какое время выполняются алгоритмы.
         * Сложность алгоритма описывается через кол-во операций, нужных для достижения р-та.
         * О(1) - сложность порядка 1. Алгоритм выполняется за постоянное const время. Самый эффективный, быстрый. Например, метод get в массиве будет
         одинаково выполняться по времени для 1‑го элемента и 99го.
         * O(n) - сложность порядка n. Линейный алгоритм или линейно масштабируемый. Например, сложение всех элементов в массиве.
         Чем больше элементов в массиве, тем больше операций потребуется для выполнения операции сложения всех элементов массива.
         * O(logn) - логарифмическая сложность. По скорости хуже О(1), но лучше O(n).
         Простейший пример, где используется O(logn) - бинарный поиск. В таком примере O(n) был бы просто перебор и был бы хуже, чем O(logn).
         */

        //Пример, почему метод get в массиве является O(1) и выполняется всегда за одно время.
        int[] array = new int[4]; // Массив инта на 4 элемента. Каждый инт занимает в памяти 4 байта.
        array[0] = 1;
        // Например, память была выделена под массив на участке 100 байт.
        // Тогда get будет искать элемент с индексом 3: 100 + 3 * 4 = 112 на участке памяти 112 байт;
        // С индексом 4: 100 + 4 * 4 = 116 на участке памяти 116 байт.
        System.out.println(Arrays.toString(array));

        String[] stringArray = new String[4];
        stringArray[0] = "aaa"; // String является объектом ссылочного типа. Поэтому на самом деле stringArray[0] хранит не значение "aaa", а ссылку на этот объект.
        stringArray[1] = "bbb";
        // Таким образом, 0 элементу массива мы даем адрес (ссылку) на этот объект "aaa".
        // На ссылки выделяется по 8 байт памяти. Таким образом, массиву не важно, сколько памяти выделилось для создания объекта String "aaa".
        // Массив хранит именно ссылку на этот объект, а на ссылку отведено 8 байт.
        // Например, память была выделена под массив на участке 100 байт.
        // Тогда get будет искать элемент с индексом 3: 100 + 3 * 8 = 124 на участке памяти 124 байт; Найдет ссылку и по ссылке мы уже получим значение String "bbb".
        System.out.println(Arrays.toString(stringArray));
        System.out.println("_________________________________________________________________________________________");


        //Еще один пример O(1) и O(n) на примере array/arrayList
        List<Integer> ints = new ArrayList<>(3);
        ints.add(0);// O(1)
        ints.add(1);// O(1)
        ints.add(2);// O(1)
        ints.add(3);// O(n) - т.к. память не была изначально выделена, элементы копируются в новый arrayList с Capacity 4
        System.out.println(ints);
        ints.remove(3); // O(1) - т.к. не происходит смещение других элементов
        ints.remove(1); // O(n) - т.к. происходит смещение других элементов после удаления элемента из середины
        System.out.println(ints);
        ints.add(1, 666);// O(1)
        System.out.println(ints); //O(n) - т.к. происходит смещение других элементов после добавления элемента в середину
        System.out.println("_________________________________________________________________________________________");

        //Еще один пример O(1) и O(n) на примере Linked List
        List<Integer> ints2 = new LinkedList<>();
        ints2.add(0);//  добавление в конец O(1), т.к. в Linked List не нужно пересоздавать массив, а только переопределить ссылки
        ints2.add(1);// O(1)
        ints2.add(44);// O(1)
        ints2.add(55);// O(1)
        ints2.add(666);// O(1)
        System.out.println(ints2);

        ints2.add(3, 777);// O(n) - т.к. в  Linked List проход до элемента происходит через все предшествующие элементы (нет моментального получения элемента, как в массиве или листе),
        // аналогично и с удалением. Т.Е. не нужно пересоздавать в массив, как в arrayList, но нужно еще дойти до индекса элемента, в который мы добавляем удаляем,
        // а это происходит через последовательный проход по всем элементам до нужной позиции.
        System.out.println(ints2);
        ints2.add(0, 888);//  добавление в начало O(1), т.к. в Linked List не нужно пересоздавать массив, а только переопределить ссылки



    }
}
